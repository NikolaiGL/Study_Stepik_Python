# 1.4 Пространства имён и области видимости
# Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку
# создания пространств имен и добавление в них переменных.
#
# В данной задаче у каждого пространства имен есть уникальный текстовый идентификатор – его имя.
#
# Вашей программе на вход подаются следующие запросы:
#
# create <namespace> <parent> –  создать новое пространство имен с именем <namespace> внутри пространства <parent>
# add <namespace> <var> – добавить в пространство <namespace> переменную <var>
# get <namespace> <var> – получить имя пространства, из которого будет взята переменная <var> при запросе из
# пространства <namespace>, или None, если такого пространства не существует
# Рассмотрим набор запросов
#
# add global a
# create foo global
# add foo b
# create bar foo
# add bar a
# Структура пространств имен описанная данными запросами будет эквивалентна структуре пространств имен, созданной
# при выполнении данного кода
#
# a = 0
# def foo():
#   b = 1
#   def bar():
#     a = 2
# В основном теле программы мы объявляем переменную a, тем самым добавляя ее в пространство global. Далее мы
# объявляем функцию foo, что влечет за собой создание локального для нее пространства имен внутри пространства global.
# В нашем случае, это описывается командой create foo global. Далее мы объявляем внутри функции foo функцию bar,
# тем самым создавая пространство bar внутри пространства foo, и добавляем в bar переменную a.
#
# Добавим запросы get к нашим запросам
#
# get foo a
# get foo c
# get bar a
# get bar b
# Представим как это могло бы выглядеть в коде
#
# a = 0
# def foo():
#   b = 1
#   get(a)
#   get(c)
#   def bar():
#     a = 2
#     get(a)
#     get(b)
# Результатом запроса get будет имя пространства, из которого будет взята нужная переменная.
# Например, результатом запроса get foo a будет global, потому что в пространстве foo не объявлена переменная a,
# но в пространстве global, внутри которого находится пространство foo, она объявлена. Аналогично, результатом
# запроса get bar b будет являться foo, а результатом работы get bar a будет являться bar.
#
# Результатом get foo c будет являться None, потому что ни в пространстве foo, ни в его внешнем пространстве global
# не была объявлена переменная с.
#
# Более формально, результатом работы get <namespace> <var> является
#
# <namespace>, если в пространстве <namespace> была объявлена переменная <var>
# get <parent> <var> – результат запроса к пространству, внутри которого было создано пространство <namespace>,
# если переменная не была объявлена
# None, если не существует <parent>, т. е. <namespace> – это global
# Формат входных данных
# В первой строке дано число n (1 ≤ n ≤ 100) – число запросов.
# В каждой из следующих n строк дано по одному запросу.
# Запросы выполняются в порядке, в котором они даны во входных данных.
# Имена пространства имен и имена переменных представляют из себя строки длины не более 10, состоящие из
# строчных латинских букв.
#
# Формат выходных данных
# Для каждого запроса get выведите в отдельной строке его результат.

# dict_req = {}   # создаем пустой словарь
# def my_func(req, namesp, var):
#     dict_req
#
# n = int(input())  # получаем кол-во запросов
# for _ in range(n):
#     req, namesp, vars = input().split()  # получаем запросы
#     dict_req[namesp] = [vars, ]
# print(req, namesp, vars)


n = int(input())                                         # получаем кол-во запросов
dict_req = {'global': {'parent': None, 'vars': []}}      # создаем шаблон словаря


def my_func(ns, v):
    """Обработка запроса get рекурсией"""
    for var in dict_req[ns]['vars']:                     # перебираем значения ключа vars в namespace
        if var == v:                                     # если находим
            return ns                                    # то возвращаем namespace
    if dict_req[ns]['parent'] is None:                   # если не находим в global(е)
        return None                                      # то возвращаем None
    parent_ns = dict_req[ns]['parent']                   # пока не дошли до global
    return my_func(parent_ns, v)                         # делаем рекурсию, изменяя namespace, но переменная таже


for _ in range(n):                                       # цикл повторяется n раз
    req, name_sp, var = input().split()                  # получаем три параметра запроса
    if req == 'create':                                  # если тип запроса create
        dict_req[name_sp] = {'parent': var, 'vars': []}  # добавляем ключ - значение в словарь
    elif req == 'add':                                   # если тип запроса add
        dict_req[name_sp]['vars'].append(var)            # добавляем переменные в список значений ключа vars
    elif req == 'get':                                   # если тип запроса get
        a = my_func(name_sp, var)                        # передаем аргументы в функцию my_func
        print(a)                                         # выводим результаты работы функции
